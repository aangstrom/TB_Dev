{
  "entityType" : "CONVERTER",
  "entity" : {
    "additionalInfo" : {
      "description" : ""
    },
    "configuration" : {
      "scriptLang" : "TBEL",
      "decoder" : null,
      "tbelDecoder" : "// Decode an uplink message from a buffer\r\n// payload - array of bytes\r\n// metadata - key/value object\r\n\r\nvar json = decodeToJson(payload);\r\nvar plc = (json && json.plcData) ? json.plcData : {};\r\n\r\n// --- Safe helpers ---\r\nfunction nz(v, d) { return (v !== undefined && v !== null) ? v : d; }\r\n\r\nvar colors = (plc.colors && typeof plc.colors === 'object') ? plc.colors : {};\r\nvar R = nz(colors.R, 0);\r\nvar G = nz(colors.G, 0);\r\nvar B = nz(colors.B, 0);\r\n\r\n// --- Base telemetry (existing)\r\nvar telemetry = {};\r\ntelemetry[\"inp1\"]   = nz(plc.inp1, 0);\r\ntelemetry[\"relay1\"] = nz(plc.relay1, 0);\r\ntelemetry[\"relay2\"] = nz(plc.relay2, 0);\r\ntelemetry[\"relay3\"] = nz(plc.relay3, 0);\r\ntelemetry[\"key\"]    = nz(plc.key, 0);\r\ntelemetry[\"reset\"]  = nz(plc.resetStatus, 0);\r\n\r\n// --- New sensor telemetry from plcData ---\r\ntelemetry[\"temperature\"] = nz(plc.temperature, null);          // Â°C\r\ntelemetry[\"humidity\"]    = nz(plc.humidity, null);             // %\r\ntelemetry[\"R\"]           = R;\r\ntelemetry[\"G\"]           = G;\r\ntelemetry[\"B\"]           = B;\r\n\r\n// Include voc only if it exists (TVOC ready); otherwise omit\r\nif (plc.voc !== undefined && plc.voc !== null) {\r\n  telemetry[\"voc\"] = plc.voc;                                  // ppb\r\n}\r\n\r\n// Convert Interval ms -> seconds if present\r\nif (plc.Interval !== undefined && plc.Interval !== null) {\r\n  telemetry[\"Interval\"] = Number(plc.Interval) / 1000.0;       // seconds\r\n}\r\n\r\n// Optional booleans/ints if present\r\nif (plc.ventola !== undefined && plc.ventola !== null) {\r\n  telemetry[\"ventola\"] = plc.ventola;\r\n}\r\nif (plc.riscaldante !== undefined && plc.riscaldante !== null) {\r\n  telemetry[\"riscaldante\"] = plc.riscaldante;\r\n}\r\n\r\n// --- Attributes (none added yet; keep object for future) ---\r\nvar attributes = {};\r\n\r\n// --- Edge detection on relay1 (existing logic) ---\r\nvar prevRelay1 = (metadata.prevRelay1 !== undefined && metadata.prevRelay1 !== null) ? metadata.prevRelay1 : null;\r\nvar currRelay1 = telemetry[\"relay1\"];\r\n\r\nif (prevRelay1 !== null) {\r\n  if (prevRelay1 === 0 && currRelay1 === 1) {\r\n    telemetry[\"aperto\"] = 1;   // rising edge\r\n  } else if (prevRelay1 === 1 && currRelay1 === 0) {\r\n    telemetry[\"chiuso\"] = 0;   // falling edge\r\n  }\r\n}\r\n// Store for next invocation\r\nmetadata.prevRelay1 = currRelay1;\r\n\r\nreturn {\r\n  deviceName: \"M5\",\r\n  deviceType: \"test\",\r\n  attributes: attributes,\r\n  telemetry: telemetry\r\n};",
      "encoder" : null,
      "tbelEncoder" : null,
      "updateOnlyKeys" : null
    },
    "converterVersion" : 1,
    "debugMode" : false,
    "debugSettings" : {
      "allEnabled" : false,
      "allEnabledUntil" : 1751640111743,
      "failuresEnabled" : true
    },
    "edgeTemplate" : false,
    "externalId" : null,
    "id" : {
      "entityType" : "CONVERTER",
      "id" : "ed6926f0-58e2-11f0-9cc7-dfa7f57094de"
    },
    "integrationType" : "MQTT",
    "name" : "stam PLC armadi",
    "type" : "UPLINK"
  },
  "relations" : [ ],
  "attributes" : {
    "SERVER_SCOPE" : [ ]
  }
}